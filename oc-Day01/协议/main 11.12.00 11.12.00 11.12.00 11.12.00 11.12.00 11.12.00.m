//
//  main.m
//  协议
//
//  Created by DXM on 2022/7/18.
//
/*
 1.协议：protocol。
   作用：
    1）用来声明很多方法
    2）只要某个类遵守了这个协议。就相当于拥有这个协议中的所有方法的声明。而不用自己去定义。
 
 2.协议的声明
   @protocol 协议名称<NSObject>
   方法的声明；
   @end
 
   新建一个协议的方式。NewFile OC-File-protocol
   协议的文件名：.h并且只有1个.h文件
   
   在协议中，只能用来声明方法，协议的作用：就是专门用来写方法声明的
   
   
 3.类遵守协议
   如果想要让1个类，拥有协议中定义的所有的方法声明。那么就让这个类遵守这个协议
   类只要遵守1个协议，那么这个类就拥有了这些协议中定义的所有的方法的声明了
 
  @interface 类名:父类名<协议名称>
 
  @end
  ：表示继承
  <>表示遵守的协议
 
  类应该自己去实现协议中的方法
  如果类不实现协议中的方法，其实也不会报错。表一起只是会报警告
  但是当创建对象，来调用这个没有实现的协议中的方法的时候，就会报错
 
 4.类是单继承。但是协议可以多遵守
   
   1个类只能有1个父类
   但是1个类可以同时遵守多个协议
   
   @interface 类名：父类名 <协议名称1，协议名称2.....>
   @end
   当1个类遵守了多个协议之后，就相当于这个类拥有了所有协议中定义的方法的声明
   那么这个类，就应该实现所有协议中的方法
 
   如果不实现，其实也不会报错，编译器只是警告。
   但是当创建对象，来调用这个没有实现的协议中的方法的时候，就会报错。
 
 5.@required与@optional
   在协议中，如果方法的声明被@required修饰，那么遵守这个协议的类必须要实现这个方法，否则编译器会发出警告
   在协议中，如果方法的声明被@optional修饰，那么遵守这个协议的类如果不实现这个方法。编译器也不会报警告。
  
   其实，无论是@required还是@optional你都可以不实现。编译器是不会报错的。仍然可以编译运行
   唯一的区别就是：当遵守协议的类不实现协议中的方法的时候。@required会给1个警告。@optional警告都没有
  
   默认的是@required
   
 6.协议和协议之间可以相互继承
   
 1）。继承的语法：
     @protocol 协议名称<父协议名称>
     @end
 2）。效果：
     子协议中不仅有自己的方法的声明，还有赋协议中的所有的方法的声明。
      
 
 
 7.NSObject
   
  在Foundation框架中，有1个类 叫做NSObject 是所有OC类的基类
  在Foundation框架中，有1个协议。叫做NSObject。
 
  NSObject协议被NSObject类遵守。所以，NSObject协议中的所有的方法 全部的OC类都拥有了
  这么说，所有的OC类都遵守了NSObject协议。NSObject协议叫做基协议
 
  类的名称可以和协议的名称一致。
 
 8.写协议的规范：
   要求所有的协议都必须直接的或者间接的从NSObject基协议继承
 
 
 */



#import <Foundation/Foundation.h>

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        // insert code here...
        NSLog(@"Hello, World!");
    }
    return 0;
}
